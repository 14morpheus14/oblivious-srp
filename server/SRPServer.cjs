/*
 * Oblivious SRP Library
 *
 * Copyright (c) 2024 Yamya Reiki <reiki.yamya14@gmail.com>
 *
 * This file is part of the Oblivious SRP library.
 *
 * Oblivious SRP is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This library is licensed under the GPLv3, which means that you can use,
 * modify, and distribute it freely, but you cannot incorporate it into
 * proprietary software. Any derivative work must also be licensed
 * under the same terms, ensuring that it remains free for all users.
 *
 * Oblivious SRP is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * In no event and under no legal theory, whether in tort (including negligence),
 * contract, or otherwise, unless required by applicable law (such as deliberate
 * and grossly negligent acts) or agreed to in writing, shall any contributor be
 * liable to you for damages, including any direct, indirect, special, incidental,
 * or consequential damages of any character arising as a result of this software
 * or out of the use or inability to use the software (including but not limited to
 * damages for loss of goodwill, work stoppage, computer failure or malfunction, or
 * any and all other commercial damages or losses), even if such contributor has
 * been advised of the possibility of such damages.
 *
 * You should have received a copy of the GNU General Public License
 * along with Oblivious SRP. If not, see <https://www.gnu.org/licenses/>.
 */


const TypeSRP = require('../util/type-srp.cjs'); // SRP integer utility
const params = require('../util/params.cjs');  // SRP parameters
const OPRFServerHandler = require('./OPRFServer.cjs');

class SRPServer {
  constructor(OPRFrateLimitWindowMs, OPRFrateLimitMaxRequests) {
    const oprfKey = TypeSRP.randomInteger(params.hashOutputBytes);
    this.oprfKey = oprfKey.toUint8Array();
    this.oprfServer = new OPRFServerHandler(this.oprfKey); // Create the OPRF Server Handler;

    this.rateLimitWindowMs = OPRFrateLimitWindowMs; // 1 minute window
    this.rateLimitMaxRequests = OPRFrateLimitMaxRequests; // Maximum 10 requests per username per minute
    this.requestLogs = {}; // Object to track requests per username
  }

  /**
  * Check if the username has exceeded the allowed request limit.
  * @param {string} username - The username to check.
  * @returns {boolean} - True if the username is rate-limited, otherwise false.
  */
  isRateLimited(username) {
    const currentTime = Date.now();
    if (!this.requestLogs[username]) {
      // Initialize request log for username if not already present
      this.requestLogs[username] = [];
    }

    // Filter out requests that are older than the rate limit window
    this.requestLogs[username] = this.requestLogs[username].filter(
      timestamp => currentTime - timestamp <= this.rateLimitWindowMs
    );

    // Check if the number of requests exceeds the limit
    if (this.requestLogs[username].length >= this.rateLimitMaxRequests) {
      return true; // User is rate-limited
    }

    // Log the current request time
    this.requestLogs[username].push(currentTime);
    return false; // User is not rate-limited
  }
  
  /**
  * Perform the OPRF Evaluation on SRP Client's private input, with rate limiting.
  * @param {string} username - The username performing the request.
  * @param {Uint8Array} serializedEvalReq - The evaluation request generated by SRP client.
  * @returns {Uint8Array} The serialized OPRF evaluation by SRP server.
  * @throws {Error} If the username is rate-limited.
  */
  async performOPRFEval(username, serializedEvalReq) {
    if (this.isRateLimited(username)) {
      throw new Error('Rate limit exceeded for username: ' + username);
    }

    // Deserialize the request
    const evalReq = this.oprfServer.deserializeEvaluationRequest(serializedEvalReq);
    // Perform the OPRF evaluation
    const evaluation = await this.oprfServer.performBlindEvaluate(evalReq);
    // Serialize the response
    const serializedEvaluation = this.oprfServer.serializeEvaluationResponse(evaluation);
    return serializedEvaluation;
  }
  
  /**
   * Generate the server's ephemeral values for SRP: 
   * Secret (b) and public (B), where B = k*v + g^b % N.
   * @param {string} publicVerifier - The publicVerifier (v) = g^(H(v'||v1'||v2'||...||vn')).
   * @returns {Object} Contains the secret and public ephemeral values in hexadecimal format.
   */
  generateEphemeral(publicVerifier) {
    const { N, g, k } = params; // SRP modulus (N), generator (g) and Multiplier parameter (k = H(N, g) in SRP-6a)
    const v = TypeSRP.fromHex(publicVerifier);
    let b = TypeSRP.randomInteger(params.hashOutputBytes); // Generate random secret 'b'
    const B = k.multiply(v).add(g.modPow(b, N)).mod(N); // Compute public ephemeral B = kv + g^b % N
    return { secret: b.toHex(), public: B.toHex() }; // Return secret and public values in hex
  }
  
  /**
   * Derive the session key and proof based on the server's secret ephemeral, 
   * client's public ephemeral, salt, username, publicVerifier, and client's session proof.
   * @param {string} serverSecretEphemeral - The server's secret ephemeral (b) in hex.
   * @param {string} clientPublicEphemeral - The client's public ephemeral (A) in hex.
   * @param {string} salt - The user's salt in hex.
   * @param {string} username - The user's username.
   * @param {string} publicVerifier - The client's public verifier (v) in hex.
   * @param {string} clientSessionProof - The client's session proof in hex. 
   * @returns {Object} Contains the session key (K) and proof (M) in hex.
   */
  deriveSession(serverSecretEphemeral, clientPublicEphemeral, salt, username, publicVerifier, clientSessionProof) {
    const { N, g, k, H } = params; // SRP modulus (N), generator (g) and Multiplier parameter (k = H(N, g) in SRP-6a), H() argon2-based Hash function
    const b = TypeSRP.fromHex(serverSecretEphemeral); // b = Server's secret ephemeral value
    const A = TypeSRP.fromHex(clientPublicEphemeral); // A = Client's public ephemeral value
    const s = TypeSRP.fromHex(salt); // s = User's salt
    const I = String(username); // I = Username
    const v = TypeSRP.fromHex(publicVerifier); // v = Public Verifier

    const B = k.multiply(v).add(g.modPow(b, N)).mod(N); // B = kv + g^b
    
    // Check if client's public ephemeral (A) is valid (A % N != 0)
    if (A.mod(N).equals(TypeSRP.ZERO)) {
      throw new Error('Client sent an invalid public ephemeral');
    }

    const u = H(A, B); // u = H(A, B)
    const S = A.multiply(v.modPow(u, N)).modPow(b, N); // S = (Av^u) ^ b
    const K = H(S); // K = H(S)
    const M = H(H(N).xor(H(g)), H(I), s, A, B, K); // M = H(H(N) xor H(g), H(I), s, A, B, K)

    const expected = M;
    const actual = TypeSRP.fromHex(clientSessionProof);

    if (!actual.equals(expected)) {
      throw new Error('Client sent an invalid session proof');
    }

    const P = H(A, M, K); // P = H(A, M, K)

    return {
      key: K.toHex(),
      proof: P.toHex()
    }
  }
}

module.exports = SRPServer;
